{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Atlas Gradle Plugin","text":"<p>Atlas is a Gradle plugin for generating, configuring and curating diagrams to illustrate your project's module structure:</p> <ol> <li>Fully supports Gradle 9 and its configuration caching.</li> <li>Supports three separate frameworks as outputs:<ul> <li>D2: Official docs here</li> <li>Graphviz: Official docs here</li> <li>Mermaid: Official docs here</li> </ul> </li> <li>Offers wide-ranging APIs for customizing your charts</li> <li>Supports <code>gradle check</code>-ing your generated diagrams, to validate that they match the current state of your project</li> <li>Supports attaching the chart generation to IntelliJ's sync button, so you don't even need to run it manually.</li> </ol> <p>Inspiration</p> <p>This project was built as a spiritial successor to com.vanniktech.dependency.graph.generator project - but with more configurability and targeting modern Gradle releases.</p>"},{"location":"#installation","title":"Installation","text":"<p>For proper release builds, you want to add the central repository to your <code>settings.gradle.kts</code> file:</p> <pre><code>pluginManagement {\n  repositories {\n    mavenCentral()\n  }\n}\n</code></pre> <p>Or for pre-release snapshots builds (the latest state of the main branch in this repo), add the Maven Central snapshots repo:</p> <pre><code>pluginManagement {\n  repositories {\n    maven(\"https://central.sonatype.com/repository/maven-snapshots/\")\n  }\n}\n</code></pre> <p>Then in your root <code>build.gradle.kts</code> file:</p> <pre><code>plugins {\n  // \ud83d\udea8\ud83d\udea8\ud83d\udea8 WARNING: You can only apply one of these at a time! \ud83d\udea8\ud83d\udea8\ud83d\udea8\n  id(\"dev.jonpoulton.atlas.d2\") version \"x.y.z\"\n  id(\"dev.jonpoulton.atlas.graphviz\") version \"x.y.z\"\n  id(\"dev.jonpoulton.atlas.mermaid\") version \"x.y.z\"\n}\n</code></pre> <p>Then generate your diagrams by running:</p> <pre><code>gradle atlasGenerate\n</code></pre> <p>or validate them by running:</p> <pre><code>gradle atlasCheck\n</code></pre> <p>That's all you need to get it working! See the next pages for further configuration of each of the above plugins.</p>"},{"location":"samples/","title":"Samples","text":"AB <p>Tab A contents</p> <p>Tab B contents</p>"},{"location":"usage-common/","title":"Configuration","text":""},{"location":"usage-common/#overview","title":"Overview","text":"<p>Configuration is primarily done via the <code>atlas</code> Gradle extension function, accessible in your root build file. See here for the KDoc, or here for the source file.</p> <pre><code>// none of these are required - these values are the defaults\natlas {\n  alsoTraverseUpwards = false\n  checkOutputs = true\n  displayLinkLabels = false\n  generateOnSync = false\n  groupModules = false\n  ignoredConfigs = setOf(\"debug\", \"kover\", \"ksp\", \"test\")\n  ignoredModules = emptySet&lt;String&gt;()\n  printFilesToConsole = false\n\n  pathTransforms {\n    // ...\n  }\n\n  moduleTypes {\n    // ...\n  }\n\n  linkTypes {\n    // ...\n  }\n}\n</code></pre> <p>Alternatively, if calling from a <code>buildSrc</code> Kotlin file (or similar):</p> <pre><code>project.extensions.configure&lt;AtlasExtension&gt; {\n  // ...\n}\n</code></pre> <p>Any other configs beyond these are specific to the particular plugin you applied, see:</p> <ul> <li>Graphviz</li> <li>D2</li> <li>Mermaid</li> </ul>"},{"location":"usage-common/#alsotraverseupwards","title":"alsoTraverseUpwards","text":"<pre><code>atlas {\n  alsoTraverseUpwards = true\n}\n</code></pre> <p>If enabled, the generated module graph will also go \"upwards\", showing modules consuming this one, as well as the default \"downwards\" - modules being consumed by this one.</p> <p>Examples below from the perspective of <code>:android:lib</code>:</p> Disabled (default) Enabled"},{"location":"usage-common/#checkoutputs","title":"checkOutputs","text":"<pre><code>atlas {\n  checkOutputs = true\n}\n</code></pre> <p>If enabled, a diffing task will be attached to <code>gradle check</code>. It will verify that your generated charts match the current state of the project layout, failing if not with a useful error message. Enabled by default.</p> <p>The generated task name will depend on your chosen framework (<code>D2</code>, <code>Mermaid</code> or <code>Graphviz</code>) and the file type that you're checking (<code>Chart</code> or <code>Legend</code>), e.g. <code>checkD2Chart</code> or <code>checkGraphvizLegend</code>.</p> <p>Even if this option is disabled, the task will still be created, it just won't be attached to <code>gradle check</code>.</p>"},{"location":"usage-common/#displaylinklabels","title":"displayLinkLabels","text":"<pre><code>atlas {\n  displayLinkLabels = true\n\n  linkTypes {\n    api(style = LinkStyle.Bold, displayName = \"API\")\n    implementation(LinkStyle.Dashed, color = \"red\")\n  }\n}\n</code></pre> <p>When enabled, a string label is attached on each module link, showing which configuration caused represents the link. When true, the <code>LinkTypeSpec.name</code> property will be used. Disabled by default.</p> <p>Requires some <code>linkTypes</code> to be declared - otherwise this will have no effect.</p> Disabled (default) Enabled"},{"location":"usage-common/#generateonsync","title":"generateOnSync","text":"<pre><code>atlas {\n  generateOnSync = true\n}\n</code></pre> <p>When enabled, syncing your IntelliJ IDE (including Android Studio) will automatically trigger regeneration of your module diagrams. Disabled by default.</p> <p>Danger</p> <p>Be careful enabling this on larger projects - sync time might extend quite a bit.</p>"},{"location":"usage-common/#groupmodules","title":"groupModules","text":"<pre><code>atlas {\n  groupModules = true\n}\n</code></pre> <p>Set to true if you want module charts to gather together groups of modules into bordered containers. E.g. a graph with <code>\":a\"</code>, <code>\":b\"</code> and <code>\":c\"</code> won't be grouped at all because they don't share any path segments, but <code>\":a:b\"</code> and <code>\"a:c\"</code> will be grouped together. Disabled by default.</p> <p>Tip</p> <p>Remember this will have no effect if your modules aren't nested at all.</p> <p>Warning</p> <p>Automatic layout generation will get a bit complicated for larger projects when using grouping.</p> Disabled (default) Enabled"},{"location":"usage-common/#ignoredconfigs","title":"ignoredConfigs","text":"<pre><code>atlas {\n  ignoredConfigs = setOf(\"debug\", \"kover\", \"ksp\", \"test\")\n}\n</code></pre> <p>Use this to configure Gradle <code>Configuration</code>s to ignore when collating module diagrams. Gradle does have a load of configurations floating around (depending on your project) - most of which will be practically useless when generating a diagram like this.</p> <p>Defaults to <code>setOf(\"debug\", \"kover\", \"ksp\", \"test\")</code>.</p> <p>Remember</p> <p>If you don't ignore any configurations, you might end up with double links between modules - or broken builds</p>"},{"location":"usage-common/#printfilestoconsole","title":"printFilesToConsole","text":"<pre><code>atlas {\n  printFilesToConsole = true\n}\n</code></pre> <p>Set to true to print the absolute path of any generated files to the Gradle console output. You can use this to help with scripting, if you like.</p> <p>Disabled by default.</p>"},{"location":"usage-common/#moduletypes","title":"moduleTypes","text":"<p>Use the <code>moduleTypes</code> block to identify module categories, along with the styling to apply to each one in the output chart. These stylings will depend on your choice of plugin (see their docs for details), but at a minimum, each with support setting:</p> <ul> <li>label string</li> <li>color, as a CSS color string (<code>\"chartreuse\"</code>) or hex string (<code>\"#7FFF00\"</code>)</li> <li>matcher, used to decide whether a given module should match this type:<ul> <li>pathContains - checks whether the module path (<code>\":modules:path:to:my:module\"</code>) contains a given string. Case sensitive.</li> <li>patchMatches - same as <code>pathContains</code>, but uses Regex pattern matching. You can also pass a <code>regexOptions</code> parameter to configure this more specifically, if you need.</li> <li>hasPluginId - checks whether the module has applied the given plugin ID string, e.g. <code>com.android.application</code> or <code>org.jebtrains.kotlin.jvm</code>.</li> </ul> </li> </ul> <p>Only one of these three module matchers should be specified.</p> <p>Sample usage:</p> <pre><code>atlas {\n  moduleTypes {\n    hasPluginId(\n      name = \"UI\",\n      color = \"#ABC123\",\n      pluginId = \"org.jetbrains.kotlin.plugin.compose\",\n    )\n\n    pathMatches(\n      name = \"Data\",\n      color = \"#ABCDEF\",\n      pathMatches = \".*data$\".toRegex(),\n    )\n\n    pathContains(name = \"Domain\", pathContains = \"domain\") {\n      // some custom config can go as a trailing lambda\n      // the available options here depends on the plugin variant\n    }\n  }\n}\n</code></pre> <p>A few module type quick-access functions are built into Atlas for use in the moduleTypes block if you need them:</p> <pre><code>atlas {\n  moduleTypes {\n    androidApp()\n    androidLib()\n    java()\n    kotlinJvm()\n    kotlinMultiplatform()\n    other()\n\n    // or useDefaults() to quickly add all of the above\n  }\n}\n</code></pre> <p>Warning</p> <p>Remember that the order of declaring module types does matter! When identifying a module, Atlas will use the first one and go down the list until it finds a match.</p> <p>The below example shows one module of each of the built-in module types in a sample D2 project layout:</p> <p></p> <p>Remember also that you can pass framework-specific configuration options into any module type declarations used above, with a trailing lambda. Example below comes from D2:</p> <pre><code>atlas {\n  moduleTypes {\n    androidApp {\n      shape = Shape.Hexagon\n      strokeWidth = 10\n    }\n\n    kotlinMultiplatform()\n\n    androidLibrary {\n      fontColor = \"red\"\n    }\n  }\n}\n</code></pre>"},{"location":"usage-common/#linktypes","title":"linkTypes","text":"<p>Use this block to configure categories of link to be detected in your project and drawn onto the modules chart. These are detected by Gradle's configuration names. In most cases you'll probably use <code>api</code> and <code>implementation</code> as your main link types, so these are available as quick-access config functions:</p> <pre><code>atlas {\n  linkTypes {\n    implementation(color = \"red\")\n\n    api(style = LinkStyle.Bold) {\n      // custom config here - plugin-specific\n    }\n  }\n}\n</code></pre> <p>Tip</p> <p>The <code>style</code> parameter on each of these will have different available options for each plugin. See the <code>LinkStyle</code> enum implementations for each one:</p> <ul> <li>Graphviz: Bold, Dashed, Dotted, Invis, Solid, Tapered. See here for details - specifically for \"edges\"</li> <li>Mermaid: Basic, Bold, Dashed, Invisible. See here for details</li> <li>D2: Basic, Bold, Dashed, Dotted, Invisible. See here for details</li> </ul> <p>Besides the default <code>api</code> and <code>implementation</code>, you can declare links representing other Gradle configurations too:</p> <pre><code>atlas {\n  linkTypes {\n    // All parameters are optional\n    \"compileOnly\"(\n      style = LinkStyle.Dotted,\n      color = \"#ABC123\",\n      displayName = \"Compile-Only\",\n    )\n  }\n}\n</code></pre> <p>Warning</p> <p>As with module types, remember that the order of declaration matters! Top takes priority. So if you define \"implementation\" before \"testImplementation\", you won't get any links matching the latter because they all also match the former.</p>"},{"location":"usage-common/#pathtransforms","title":"pathTransforms","text":"<p>This is a little API for modifying module paths when inserting them into any generated diagrams. For example if your modules are all within a <code>\"modules\"</code> directory in your project's root, you might want to call something like:</p> <pre><code>atlas {\n  pathTransforms {\n    // \":modules:path:to:something\" =&gt; \"path:to:something\"\n    remove(\"^:modules:\")\n\n    // \"path:to:something\" =&gt; \"path to something\"\n    replace(\":\", replacement = \" \")\n  }\n}\n</code></pre> <p>Remember the declarations inside <code>pathTransforms</code> are called in descending order. It does not support regex group replacement (yet?) - regex is only used for pattern matching.</p>"},{"location":"usage-d2/","title":"D2","text":"<p>TBC</p>"},{"location":"usage-graphviz/","title":"Graphviz","text":"<p>TBC</p>"},{"location":"usage-mermaid/","title":"Mermaid","text":"<p>TBC</p>"}]}